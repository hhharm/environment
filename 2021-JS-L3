
****************************************************************************************************************************************************
ПАРАДИГМЫ ПРОГРАММИРОВАНИЯ
****************************************************************************************************************************************************
(Всё в контексте JS)
Инкапсуляция:
1) Привязывание методов и данных; изоляция методов и данных от внешнего мира; security (безопасность)
2) В 2021 будет private в классах, под капотом сделан через weak map
3) get, set
4) инкапсуляция модулями
5) инкапсуляция через замыкание. Области видимости

Наследование:
1) Под капотом прототипы
2) Цепочка прототипов заканчивается на null (Object ссылается на null)
у инстанса класса есть proto, оно ссылается на consturtor => function prototype => Object proto => null
3) Прототипное наследование гибче - можно у уже созданного инстанса подменить proto
4) new - записать в конструктор прототайп
5) The __proto__ property is a bit outdated. It exists for historical reasons, modern JavaScript suggests that we should use Object.getPrototypeOf/Object.setPrototypeOf functions instead that get/set the prototype.
6) лучше не перезаписывать прототайпы, а расширять их
7) gorilla banana problem - хочешь банан, а получаешь в придачу гориллу. 
AP: прочитать про проблему и какими паттернами её можно решить

Полиморфизм:
1) Ad hoc полиморфизм (a-la перенагрузка - выбор реализации в зависимости от типа параметров). Оно есть в TS! И последняя перегрузка должна содержать все возможные параметры, иначе будет ошибка компиляции.
В JS можно сделать, но придётся вручную разруливать
2) Параметрический полиморфизм - реализация одинаковая вне зависимости от типа параметров
Переопределение методов дочерних классов (динамический)
shadowing

vs java/c# ?

Абстракция:
1) отражение реальной сущности в набор методов и свойств
2) абстрактный класс vs интерфейс - в интерфейсе все методы абстрактные, в абстрактном классе можно что-то реализовать.
3) интерфейс компилируется ни во что, абстрактный класс компилируется в класс
4) нельзя создать инстанс абстрактного класса
5) инкапсуляция - частный случай абстракции

Императивное программирование vs декларативное(стили):
Императивное - как делать. Инструкции, строчка за строчкой. Циклы, ветвления.
Декларативное - что именно делать. Операции вынесены в отдельные функции.
Яркий пример декларативного -  SQL.
ООП ближе к императивному, функциональное программирование ближе к декларативному

Angular - директивы это декларативное программирование
React - больше декларативное программирование
но всё равно и то, и то используется

Функциональное программирование:
Чистые функции: при одинаковом input всегда один output, нет side effects. Нет мутирования входных параметров и нет изменения/использования внешних состояний. 
Возможно мемоизирование (memoisation), т.е. кеширование результатов.
Можно подменить результат вычисления на вызов функции.

immutable - не меняет внутренние значения. При передачи в функцию можно создать клон
redux - пишет новый state на каждое изменение
typescript - readonly
+ предсказуемость
- использование памяти


функция первого класса - функция, с которой можно работать как с данными (заменять данные на её вызов)

функции высшего порядка - функции, которые оперируют функциями и возвращают функции. Каррирование

рекурсия - вместо циклов в FP, т.к. не изменяется состояние.


Функциональное программирование vs OOP
* в ооп хранится внутреннее состояние, а в функциональном программировании нет.

* в ооп данные и манипулирование ими хранится в одной сущности
* в функциональном программировании используется пайп над данными (данные с BE => ... => ... => ... => готовая вёрстка)

функциональное
+ не нужно тратить время на продумывание абстракций


OOP
+ есть наследование
+ легче порог входа

- очень легко ошибиться в проектировании системы классов. Gorilla with bananas, overengineering. Сложно разделить ответственность.

Реактивное программирование:
событие => реакция
при изменении состояния пересчитываются все зависимые значения
stream
observable
subject
"декларативный подход работы с асинхронными данными, распределёнными по времени"

RxJs . Паттерн Observer. MobX
